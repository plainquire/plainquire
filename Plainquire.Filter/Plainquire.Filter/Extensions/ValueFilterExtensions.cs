using Plainquire.Filter.Abstractions;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Plainquire.Filter;

/// <summary>
/// Extension methods for <see cref="ValueFilter"/>.
/// </summary>
public static class ValueFilterExtensions
{
    /// <summary>
    /// Humanizes the filter syntax.
    /// </summary>
    /// <typeparam name="TValue">The type of the filtered value.</typeparam>
    /// <param name="filterSyntax">The filter syntax.</param>
    /// <param name="valueName">Name of the value.</param>
    /// <param name="configuration">The filter configuration to use.</param>
    public static string HumanizeFilterSyntax<TValue>(this string? filterSyntax, string valueName, FilterConfiguration? configuration = null)
    {
        if (string.IsNullOrWhiteSpace(filterSyntax))
            return $"{valueName} is unfiltered";

        var filters = ValueFiltersFactory.Create(filterSyntax, configuration)
            .GroupBy(x => x.Operator)
            .Select(filterGroup =>
            {
                var filterOperator = filterGroup.Key;
                var operatorName = filterOperator.GetOperatorName<TValue>();

                if (filterOperator is FilterOperator.IsNull or FilterOperator.NotNull)
                    return $"{valueName} {operatorName}";

                var filterValues = filterGroup.Select(x => x.Value).ToArray();
                var valuesButLast = filterValues[..^1];
                var prefixValueList = string.Join("', '", valuesButLast);
                var valueList = !string.IsNullOrEmpty(prefixValueList)
                    ? $"'{prefixValueList}' or '{filterValues[^1]}'"
                    : $"'{filterValues[^1]}'";

                return $"{valueName} {operatorName} {valueList}";
            })
            .ToList();

        return string.Join(" or ", filters);
    }

    /// <summary>
    /// Creates filter micro syntax string from <see cref="ValueFilter"/>.
    /// </summary>
    /// <param name="filters">The filters.</param>
    /// <autogeneratedoc />
    public static string? ToString(IReadOnlyCollection<ValueFilter>? filters)
    {
        if (filters == null)
            return null;

        var filterStrings = filters
            .Where(x => x != null)
            .Select(x => x.ToString()?.Replace(",", "\\,"));

        return string.Join(",", filterStrings);
    }

    private static string GetOperatorName<TValue>(this FilterOperator filterOperator)
    {
        filterOperator = filterOperator != FilterOperator.Default ? filterOperator : GetDefaultOperator<TValue>();
        return filterOperator switch
        {
            FilterOperator.Contains => "contains",
            FilterOperator.StartsWith => "starts with",
            FilterOperator.EndsWith => "ends with",
            FilterOperator.EqualCaseSensitive => "is (case-sensitive)",
            FilterOperator.EqualCaseInsensitive => "is",
            FilterOperator.NotEqual => "is not",
            FilterOperator.LessThanOrEqual => "is less than or equal to",
            FilterOperator.LessThan => "is less than",
            FilterOperator.GreaterThanOrEqual => "is greater than or equal to",
            FilterOperator.GreaterThan => "is greater than",
            FilterOperator.IsNull => "is null",
            FilterOperator.NotNull => "is not null",
            _ => throw new ArgumentOutOfRangeException(nameof(filterOperator))
        };
    }

    private static FilterOperator GetDefaultOperator<TValue>()
        => typeof(TValue) == typeof(string)
            ? FilterOperator.Contains
            : FilterOperator.EqualCaseInsensitive;
}